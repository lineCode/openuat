/* Copyright Rene Mayrhofer
 * File created 2006-06-06
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */
package org.eu.mayrhofer.sensors;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;

import gnu.io.CommPortIdentifier;
import gnu.io.NoSuchPortException;
import gnu.io.PortInUseException;
import gnu.io.SerialPort;
import gnu.io.UnsupportedCommOperationException;

import org.apache.log4j.Logger;

/** This class implements a reader for the "RAW" data format generated by 
 * Spark Fun Electronics WiTilt v2.5 sensors. It is a simple ASCII-based
 * format in the form:
 * 
 * X=526    Y=473   Z=741
 * X=522    Y=481   Z=753
 * X=514    Y=480   Z=747
 * X=518    Y=474   Z=748
 * X=521    Y=481   Z=745
 * 
 * This class depends on the devices being pre-configured appropriately, e.g.
 * to sample all 3 axises and with the correct sampling rate. They also need to
 * be configured to generate their "RAW" data stream. 
 * 
 * @author Rene Mayrhofer
 * @version 1.0
 */
public class WiTiltRawReader extends AsciiLineReaderBase {
	/** Our log4j logger. */
	private static Logger logger = Logger.getLogger(WiTiltRawReader.class);

	private final static int BAUDRATE = 57600;
	
	private final static String MENU_HEADER = "WiTilt Firmware v3 - Configuration Menu:";
	
	private SerialPort serialPort = null;
	
	private OutputStream portCmd = null;
	
	/** Initializes the WiTilt RAW reder. It only saves the
	 * passed parameters and opens the InputStream to read from the specified
	 * file, and thus implicitly to check if the file exists and can be opened.
	 * 
	 * @param serialPortName The serial port to read from. It will be opened
	 *                       and initialized with the correct parameters. 
	 * @throws FileNotFoundException When filename does not exist or can not be opened.
	 */
	public WiTiltRawReader(String serialPortName) throws IOException {
		// we have a maximum of 3 values (X, Y, Z) to read per sample
		super(3);
		
		// need to initialize the serial port properly
		try {
			logger.debug("Using port '" + serialPortName + "'");
			CommPortIdentifier portId = CommPortIdentifier.getPortIdentifier(serialPortName);
			if (portId.isCurrentlyOwned()) {
				throw new IOException("port " + port + " is currently in use by " +
						portId.getCurrentOwner());
			} else {
				/* Set serial port parameters directly that are not yet accessible via the (deeply broken) javax.comm API.
				 * This is of course very OS specific, but hopefully only needs to be done once and not each time the port
				 * is opened (i.e. in prepareMode).
				 */
				if (System.getProperty("os.name").startsWith("Linux")) {
					logger.info("Using Linux-specific configuration of the serial port.");
					try {
						// WATCHME: sometimes, the option -opost fixes the "10" duplication, but is not enough 
						// ("255" duplication still happens and seems to be solved by the raw option)
						String[] cmdArgs = new String[] {"stty", "-F", serialPortName, "raw"};
						int exitCode = Runtime.getRuntime().exec(cmdArgs).waitFor();
						if (exitCode != 0) {
							logger.error("Unable to set serial port parameters to prohibit post-processing of received characters. " +
									"Exit code of 'stty -F " + port + " raw' was " + exitCode + ". " +
							        "This is non-fatal, but the device communication might now be subtly broken.");
						}
					}
					catch (InterruptedException e) {
						throw new IOException("The process was interrupted while trying to set serial port parameters with " + e + ". " +
						    "This is non-fatal, but the device communication might now be subtly broken.");
					}
					catch (IOException e) {
						throw new IOException("The process execution failed while trying to set serial port parameters with " + e + ". " +
					    "This is non-fatal, but the device communication might now be subtly broken.");
					}
				}

				try {
					serialPort = (SerialPort) portId.open("RelatePort", 500);
					try {
						serialPort.setSerialPortParams(BAUDRATE,
								SerialPort.DATABITS_8,
								SerialPort.STOPBITS_1,
								SerialPort.PARITY_NONE);
						// so that read on the getInputStream does not hang indefinitely but times out
						serialPort.enableReceiveTimeout(1000);
						if (!serialPort.isReceiveTimeoutEnabled())
							logger.warn("Warning: serial port driver does not support receive timeouts! It is possible that read operations will block indefinitely.");
						serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE);
						logger.info("Opened port " + portId.getName() + " at " + serialPort.getBaudRate());

						// also open the output stream to the port so that we can interact with the menu
						portCmd = serialPort.getOutputStream();
						port = serialPort.getInputStream();

						if (! waitForMenuControl()) {
							throw new IOException("Could not gain control of the WiTilt menu");
						}
						
						// now start the sensor output
						PrintWriter w = new PrintWriter(portCmd);
						w.print('1');
						w.flush();
					} catch (UnsupportedCommOperationException e) {
						if (! System.getProperty("os.name").startsWith("Windows CE")) {
							logger.error("UnsupportedCommOperationException: " + e + "\n" + e.getStackTrace());
						}
						else {
							// J2ME CLDC doesn't have reflection support and thus no getStackTrace()....
							logger.error("UnsupportedCommOperationException");
						}
					}
				}
				catch (IOException e) {
					throw new IOException("Could not open port for reading and/or writing: " + e);
				}
				catch (PortInUseException e) {
					throw new IOException("Could not open port for reading and/or writing: " + e);
				}
			}
		}
		catch (NoSuchPortException e) {
			throw new IOException("Could not create CommPortIdentifier object from port name '" + serialPortName + "': " + e);
		}
	}
	
	private boolean checkForMenuOutput(BufferedReader r) {
		boolean foundMenu = false;
		// drain all input
		String line;
		try {
			line = r.readLine();
			// TODO: add a timeout
			while (!foundMenu && line != null) {
				logger.debug("read from sensor: '" + line);
				if (line.indexOf(MENU_HEADER) != -1) {
					logger.debug("Detected menu start header");
					foundMenu = true;
				}
				line = r.readLine();
			}
		} catch (IOException e) {
			// simply ignore, this means that the menu output has ended (or no output at all)
			return false;
		}
		return foundMenu;
	}
	
	private boolean waitForMenuControl() {
		logger.info("Waiting to gain WiTilt menu control");
		
		try {
			BufferedReader r = new BufferedReader(new InputStreamReader(port));
			PrintWriter w = new PrintWriter(portCmd);
			
			boolean gotControl = false;
			// TODO: add a timeout
			while (!gotControl) {
				logger.info("Trying to invoke menu ...");
				// before trying to invoke the menu, drain the output
				if (checkForMenuOutput(r))
					logger.debug("Initial menu was printed before gaining control, device seems to have been reset");

				// try to get the menu to print
				w.print(' ');
				w.flush();
				
				if (checkForMenuOutput(r)) {
					logger.info("Successfully invoked menu");
					gotControl = true;
				}
				else {
					logger.info("Could not invoke menu, please reset device now");
					Thread.sleep(1000);
				}
			}
			return gotControl;
		} catch (InterruptedException e) {
			logger.error("Interrupted while trying to get menu control" + e);
			return false;
		}
	}
	
	/** This closes the serial port properly. It should <b>not</b> be called manually!
	 */
	public void dispose() {
		if (serialPort != null) {
			try {
				portCmd.close();
				port.close();
			}
			catch (IOException e) {
				logger.warn("Exception occured during closing the serial port streams: " + e);
			}
			serialPort.close();
			serialPort = null;
		}
	}
	
	/** A helper function to parse single line of the format produced by 
	 * parport-pulsewidth. This method creates the samples and emits events.
	 * @param line The line to parse.
	 */
	protected void parseLine(String line) {
		//System.out.println("got line from sensor: '" + line + "'");
		if (line.length() < 2)
			// silently ignore empty lines (they might be due to \r\n conversion)
			return;
		
		StringTokenizer st = new StringTokenizer(line, " =", false);
		try {
			double[] values = new double[maxNumLines];
			
			// just read all values
			for (int i=0; i<maxNumLines; i++) {
				char valName = (char) ('X' + i);
				String tok = st.nextToken();
				//System.out.println("token1: '" + tok + "'");
				if (! tok.equals(Character.toString(valName))) {
					logger.warn("Did not get start of " + valName + " value, skipping line");
					return;
				}
				try {
					tok = st.nextToken();
					//System.out.println("token2: '" + tok + "'");
					values[i] = Integer.parseInt(tok.trim());
				}
				catch (NumberFormatException e) {
					logger.warn("Could not parse value for " + valName + ", skipping line (" + e + ")");
				}
			}
			
			emitSample(values);
		}
		catch (NoSuchElementException e) {
			logger.warn("Could not parse line from WiTilt sensor, skipping it (" + e + ")");
		}
	}
	
	
	/////////////////////////// test code begins here //////////////////////////////
	private static class TestSamplesSink implements SamplesSink {
		private char name;
		
		public void addSample(double sample, int index) {
			System.out.println(name + ": " + sample);
		}

		public void segmentStart(int index) {
		}

		public void segmentEnd(int index) {
		}
	}
	
	public static void main(String[] args) throws IOException {
		//mainRunner("WiTiltRawReader", args);
		
		String filename = args[0];
		AsciiLineReaderBase r = new WiTiltRawReader(filename);
		TestSamplesSink[] sinks = new TestSamplesSink[3];
		for (int i=0; i<=2; i++) {
			sinks[i] = new TestSamplesSink();
			sinks[i].name = (char) (('X' + i));
		}
		r.addSink(new int[] {0, 1, 2}, sinks);
		r.simulateSampling();
	}
}
