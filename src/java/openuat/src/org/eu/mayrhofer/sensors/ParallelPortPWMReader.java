/* Copyright Rene Mayrhofer
 * File created 2006-04-27
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */
package org.eu.mayrhofer.sensors;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.StringTokenizer;

import org.apache.log4j.Logger;

/** This class implements a reader for the data format generated by the small
 * Linux native code (a C command line program) to sample pulse-width modulated
 * sensors (e.g. accelerometers) using a standard parallel port. 
 * 
 * Because the output format reports a new value whenever a change on the 
 * parallel port occurs, this class implements sampling with a defined sample
 * rate to generate equidistant sample points.
 * 
 * @author Rene Mayrhofer
 * @version 1.0
 */
public class ParallelPortPWMReader {
	/** Our log4j logger. */
	private static Logger logger = Logger.getLogger(ParallelPortPWMReader.class);

	/** This is the file name we are reading from. */
	private String filename;
	
	/** This represent the file to read from and is opened in the constructor.
	 * @see #ParallelPortPWMReader(String, int[], int)
	 */
	private InputStream port;
	
	/** The set of lines of the parallel port to read. Set by the constructor.
	 * @see #ParallelPortPWMReader(String, int[], int)
	 */
	private int[] lines;
	
	/** The length of s sample period, i.e. the sample width, in Âµsec. */
	private int sampleWidth;
	
	/** This holds all registered sinks, which must be arrays of time series. 
	 * @see #addSink(TimeSeries[])
	 * @see #removeSink(TimeSeries[])
	 */
	private LinkedList sinks;
	
	/** The current samples, i.e. all sample values that fall into the current sample period. */
	private ArrayList[] curSample;
	/** The time when the last sample was issued, in usec. */
	private long lastSampleAt = -1;
	/** Remember the last sample values, in case there is a sample period with no samples from
	 * the sensors. In this case the last values are just repeated.
	 */
	private float[] lastSampleValues;
	
	/** Initializes the parallel port PWM log reader. It only saves the
	 * passed parameters and opens the InputStream to read from the specified
	 * file, and thus implicitly to check if the file exists and can be opened.
	 * 
	 * @param filename The log to read from. This may either be a normal log file
	 *                 when simulation is intended or it can be a FIFO/pipe to read
	 *                 online data.
	 * @param lines The set of lines on the parallel port to read. Must be an integer
	 *              array with a minimum length of 1 and a maximum length of 8, containing
	 *              the indices of the lines to read. These indices are counted from 0 to 7.
	 *              for the parallel port data lines DATA0 to DATA7.
	 * @param samplerate The sample rate in Hz.
	 * @throws FileNotFoundException When filename does not exist or can not be opened.
	 */
	public ParallelPortPWMReader(String filename, int[] lines, int samplerate) throws FileNotFoundException {
		if (lines.length < 1 || lines.length > 8)
			throw new IllegalArgumentException("Number of lines to read must be between 1 and 8");
		String tmp = "";
		for (int i=0; i<lines.length; i++) {
			if (lines[i] < 0 || lines[i] > 7)
				throw new IllegalArgumentException("Line index must be between 0 and 7");
			tmp += lines[i] + " ";
		}
		
		this.filename = filename;
		this.lines = lines;
		this.sampleWidth = 1000000 / samplerate;
		this.curSample = new ArrayList[lines.length];
		this.lastSampleValues = new float[lines.length];
		
		logger.info("Reading from " + filename + ", data lines: " + tmp + 
				" with sample rate " + samplerate + " Hz (sample width " + sampleWidth + " us)");
		
		port = new FileInputStream(new File(filename));
	}
	
	/** Registers a sink, which will receive all new values as they are sampled.
	 * @param sink The time series to fill. This array must have the same number of
	 *             elements as the number of lines specified to the constructor.  
	 */
	public void addSink(TimeSeries[] sink) throws IllegalArgumentException {
		if (sink.length != lines.length)
			throw new IllegalArgumentException("Passed TimeSeries array has " + sink.length 
					+ " elements, but sampling " + lines.length + " parallel port lines");
		sinks.add(sink);
	}
	
	/** Removes a previously registered sink.
	 * 
	 * @param sink The time series to stop filling.
	 * @return true if removed, false if not (i.e. if they have not been added previously).
	 */
	public boolean removeSink(TimeSeries[] sink) {
		return sinks.remove(sink);
	}
	
	public void startSampling() {
		
	}
	
	public void stopStampling() {
		
	}
	
	public void simulateSampling() throws IOException {
		BufferedReader r = new BufferedReader(new InputStreamReader(port));
		
		String line = r.readLine();
		while (line != null) {
			parseLine(line);
			line = r.readLine();
		}
	}
	
	private void parseLine(String line) {
		StringTokenizer st = new StringTokenizer(line, " .", false);
		// first two columns (with a '.' in between) are the timestamp (sec and usec)
		int timestampSecs = Integer.parseInt(st.nextToken()); 
		int timestampUSecs = Integer.parseInt(st.nextToken());
		long timestamp = timestampSecs + timestampUSecs * 1000000;
		logger.debug("Reading at timestamp " + timestamp + " us");
		// sanity check
		if (timestamp <= lastSampleAt) {
			logger.error("Reading from the past! Aborting parsing");
			return;
		}
		
		// check if this sample creates a new sample period
		if (timestamp > lastSampleAt + sampleWidth) {
			logger.debug("Current reading creates new sample");
			
			// get the average over the last period's samples (if there are any, if not, just use the last period's samples)
			if (curSample[0].size() > 0) {
				logger.debug("Averaging over " + curSample[0].size() + " values for the last sample");
				for (int i=0; i<lines.length; i++) {
					lastSampleValues[i] = 0;
					for (int j=0; j<curSample[i].size(); j++)
						lastSampleValues[i] += ((Integer) curSample[i].get(j)).intValue();
					lastSampleValues[i] /= curSample[i].size();
					// prepare for the next (i.e. the currently starting) sample period
					curSample[i].clear();
				}
			}
			
			while (timestamp > lastSampleAt + sampleWidth) {
				lastSampleAt += sampleWidth;
				for (int i=0; i<lines.length; i++) {
					// and put into all sinks
					logger.debug("Sample for timestamp " + lastSampleAt + ", line " + lines[i] + " = " + lastSampleValues[i]);
			    	if (sinks != null)
			    		for (ListIterator j = sinks.listIterator(); j.hasNext(); ) {
			    			TimeSeries s = (TimeSeries) j.next();
			    			s.addSample(lastSampleValues[i]);
			    		}
				}
			}
		}
		
		// only continue to extract values when there are more tokens in the line
		if (st.hasMoreElements()) {
			// then the 8 data lines
			int[] allLines = new int[8];
			for (int i=0; i<7; i++)
				allLines[i] = Integer.parseInt(st.nextToken());
		
			// extract the lines we want and remember the values
			for (int i=0; i<lines.length; i++) {
				curSample[i].add(new Integer(allLines[lines[i]]));
			}
		}
		else
			logger.debug("This is an empty reading containing only a timestamp");
	}
	
	// TODO: create a general interface for a sensor source, but keep it simple --> timestamped, using TimeSeries
}
